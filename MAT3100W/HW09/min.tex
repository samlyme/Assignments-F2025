\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{mathtools, amsfonts, amsthm, amssymb, graphicx, listings, xcolor, pdfpages}

\newtheorem{proposition}{Proposition}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\title{HW09}
\author{Sam Ly}

\begin{document}
\maketitle

\section*{Required Exercise 1 [4]}

Included below.

\section*{Required Exercise 2 [3]}

\begin{proposition}
    A function \(f: A \rightarrow B\) is a bijection if and only if there 
    exists a function \(G: B \rightarrow A\) such that \(g(f(a)) = a\) for 
    all \(a \in A\) and \(f(g(b)) = b \) for all \(b \in B \).
\end{proposition}

\begin{enumerate}
    \item {
        Prove the ``forward direction'' of the proposition by assuming that 
        \(f: A \rightarrow B\) is surjective and injective, and concluding that
        there exists an inverse function.

        \begin{proof}
            Suppose that \(f: A \rightarrow B\) is a bijection. Thus,
            for every unique \(b \in B\) there exists a unique \(a \in A\) such that 
            \(f(a) = b\). 

            Therefore, there must exist the inverse function \(f^{-1}: B \rightarrow A\)
            such that for every value \(b \in B\), \(f^{-1}(b)\) is a unique 
            value \(a \in A\).
        \end{proof}
    }

    \item {
        Prove the ``backward direction'' of the proposition by assuming that \(f^{-1}: B \rightarrow A\)
        is an inverse function of \(f\), and concluding that 
        \(f \) is surjective and injective. 

        \begin{proof}
            First, we see that because \(f{-1}\) exists, \(f\) itself must be a 
            valid fumction. \(f^{-1}\) maps every value \(b \in B\) to a 
            unique value \(a \in A\). So, \(f\) must be injective because the 
            domain of \(f^{-1}\) is \(B\). Also, because \(f^{-1}\) is a valid 
            function, no two values \(a \in A\) map to the same value \(b \in B\). 
            Thus, \(f\) is injective.
        \end{proof}
    }

    \item {
        \begin{enumerate}
            \item {
                Give an example of sets \(A\) and \(B\) together with a 
                pair of functions \(f: A \rightarrow B\) and \(g: B \rightarrow A\) 
                where 
                \begin{enumerate}
                    \item \(g(f(a)) = a\) for all \(a \in A\),
                    \item there exists \(b \in B\) such that \(f(g(b) \not= b\), and 
                    \item \(f\) is not a bijection.
                \end{enumerate}

                Let sets \(A = \mathbb{N}\) and \(B = \mathbb{R}\). 
                Let \(f: \mathbb{N} \rightarrow \mathbb{R}\), where \(f(n) = n\). 
                Let \(g: \mathbb{R} \rightarrow \mathbb{N}\), where \(g(r) = \lfloor r \rfloor\).

                We see that for all \(a \in A\), \(g(f(a)) = a\). However,
                for any non-integer value \(b \in B\), \(f(g(b)) \not= b\).
                Thus, \(f\) is not a bijection. 
            }

            \item {
                Let sets \(A = \mathbb{R}\) and \(B = \{r \in \mathbb{R} : 0 \le r \le 1\}\).
                For \(f: A \rightarrow B\), \(f(x) = \sin(x)\). and 
                \(g: B \rightarrow A\), \(g(x) = \sin^{-1}(x)\).

                We see that for \(a = 4\pi \in A\), \(g(f(a)) = 0 \not= 4\pi\). 
                However, \(f(g(b)) = b\) for all \(b \in B\).
            }
        \end{enumerate}
    }
\end{enumerate}

\section*{Required Exercise 3 [3]}

\begin{enumerate}
    \item {
        Give an example of a bijection \(h: \mathbb{N}_{>0} \rightarrow \mathbb{N}_{\ge 0}\)
        Note that the domain and the codomain are different, and explain why the 
        map \(h(x) = x\) is not a bijection. 

        \(h(x) = x-1\) is a valid bijection. \(h(x) = x\) is not a bijection 
        because it is not surjective. The value \(0\) is not reached.
    }

    \item {
        Consider the function \(f: \mathbb{N}_{>0} \rightarrow \mathbb{N}_{\ge0}\)
        where 
\[
f(n) =
\begin{cases}
\dfrac{n}{2}, & \text{if } n \text{ is even} \\
-\dfrac{(n+1)}{2}, & \text{if } n \text{ is odd.}
\end{cases}
\]
        \begin{enumerate}
            \item {
                Prove that \(f\) is a bijection by proving that it is both injective 
                and surjective. 

                \begin{proof}
                    To see that \(f\) is both injective and surjective, 
                    we must first see that the individual ``peices'' of \(f\) 
                    are each injective and surjective, and that these ``pieces''
                    have mutually exclusive codomains. 

                    First, we see that for even \(n\), \(f(n) = n/2\). This is 
                    itself a valid bijection between the set \(A\) of even natural 
                    numbers including 0 and the set \(B\) of all natural numbers including 
                    0. 

                    Then, we see that for odd \(n\), \(f(n) = -\frac{n+1}{2}\). 
                    This is a valid bijection between the set \(C\) of all odd natural 
                    numbers and the set \(D\) of all negative integers.

                    Notice that the range of both ``pieces'' is equal to their 
                    codomains. 

                    Now, we see  that \(B \cap D = \emptyset\), \(A \cap C = \emptyset\), 
                    and \(A \cup B = \mathbb{N}_{\ge0}\). So, \(f\) must be injective.

                    Also, because \(B \cup D = \mathbb{Z}\), \(f\) must be surjective. 

                    Therefore, \(f\) is a bijection. 
                \end{proof}
            }

            \item {
                Prove that \(f\) is a bijection by describing a (piecewise-defined)
                function for the inverse map \(g: \mathbb{Z} \rightarrow \mathbb{N }_{\ge0}\),
                and checking that \(g \circ f: \mathbb{N }_{\ge0} \rightarrow \mathbb{N }_{\ge0}\)
                and \(f \circ g: \mathbb{Z} \rightarrow \mathbb{Z }\) are both the 
                identity function on their respective domains.

                \begin{proof}
                    Let \(g: \mathbb{Z} \rightarrow \mathbb{N }_{\ge0}\), where 
                    \[
                    g(n) =
                    \begin{cases}
                        2n & n \ge 0 \\
                        -2n-1 & n < 0
                    \end{cases}
                    \]

                    Now, we observe that \(g \circ f\) is the identity function 
                    because for all even \(n \in \mathbb{N}\), \(f(n) = n/2\). 
                    Because \(n \ge 0\), \(f(n) \ge 0\). Thus, \(g(n) = 2n\). 
                    Finally, \(g(f(n)) = n\). 
                    
                    Then, for all odd \(n \in \mathbb{N}\), \(f(n) = - \frac{n+1}{2}\). 
                    Now, \(f(n) < 0\), so \(g(n) = -2n - 1\). Thus,
                    \begin{align*}
                        g(f(n)) &= -2(-\frac{n+1}{2}) -1 \\
                        &= (n+1) - 1 = n.\\
                    \end{align*}

                    Thus, \(g \circ f\) is the identity on \(\mathbb{N}_{\ge 0}\). 

                    Also, \(f \circ g\) is the identity on \(\mathbb{Z}\) because 
                    for \(n \ge 0\), \(g(n) = 2n\) is even, and \(f(n) = n/2\). 
                    Thus, \(f(g(n)) = n\). Then for \(n < 0\), \(g(n) = -2n -1\) 
                    and \(f(n) = - \frac{n+1}{2}\). Thus, 
                    \begin{align*}
                        f(g(n)) &= -\frac{(-2n-1)+1}{2} \\
                                &= -\frac{-2n}{2} = n. \\
                    \end{align*}
                    Therefore, \(f\) is a bijection. 
                \end{proof}
            }
        \end{enumerate}
    \item {
        Describe a bijection \(s: \mathbb{N }_{>0 } \rightarrow \mathbb{Z}\) in 
        ters of \(h\) and \(f\). 

        Since \(h: \mathbb{N }_{>0} \rightarrow \mathbb{N}_{\ge0}\) and 
        \(f: \mathbb{N}_{\ge0} \rightarrow \mathbb{Z}\), \(s = f \circ h\).
    }
    }
\end{enumerate}

\section*{Choice Exercise 6 [5]}

In this exercise, you will prove that the relation ``there exists a bijection 
between'' is an equivalence relation on sets.

\begin{enumerate}
    \item {
        Prove that the relation is reflexive: for all sets \(A\), there exists 
        a bijection \(f: A \rightarrow A\). 

        \begin{proof}
            For any set \(A\), there must exist the identity function \(f\). 
            This function must be a bijection since it relates all elements of 
            set \(A\), to a unique elemeent of \(A\).
        \end{proof}
    }

    \item {
        Prove that the relation is symmetric: for all sets \(A\) and \(B\) such 
        that there exists a bijection \(f: A \rightarrow B\), there also exists 
        a bijection \(g: B \rightarrow A\).

        \begin{proof}
            For a function \(f\) to be well defined on a domain \(A\), it must 
            be defined for every value \(a \in A\). This means that, if \(f\) is 
            injective, there bust exist a surjection from \(B\) to \(A\). 
            Because \(f\) is a bijection, \(f\) must also be injective, thus 
            there exists some surjection from \(B\) to \(A\). 

            Also, since \(f\) is a surjection and well-defined, there must exist 
            an injection from \(B\) to \(A\). Therefore, there must exist a 
            bijection from \(g: B \rightarrow A\). 
        \end{proof}
    }

    \item {
        Prove that the relation is transitive: for all sets \(A\), \(B\), and
        \(C\) such that there exist bijections \(f_1: A \rightarrow B \) and 
        \(f_2 B \rightarrow C\), there also exists a bijection \(f_3: A \rightarrow C\).

        \begin{proof}
            Assume that there exists bijections \(f_1: A \rightarrow B \) and 
            \(f_2 B \rightarrow C\).

            This means that every value \(a \in A\) can be mapped to a unique 
            value \(b \in B\) by a the function \(f_1\). Also, every value \(b \in B\) 
            is mapped to by a value \(a \in A\). Similarly, every value \(b \in B\) 
            is mapped to a unique value \(c \in C\) by the function \(f_2\), 
            and all values of \(c \in C\) are mapped to by a value \(b \in B\). 

            So, this means that the composition \(f_2 \circ f_1\) first maps all 
            unique values of \(a \in A\) to a unique value \(b \in B\), then maps 
            all values \(b \in B\) to a unique value \(c \in C\). This means that 
            all elements \(a \in A\) can be mapped to a unique element \(c \in C\). 
            Also, this mapping is surjective because all values of \(C\) are reached 
            by \(f_2\), and all values of \(B\) are reached by \(f_1\). 

            Therefore, this relation is transitive.
        \end{proof}
    }
\end{enumerate}

\section*{Choice Exercise 7 [6]}

\begin{enumerate}
    \item[2.] {
        \begin{enumerate}
            \item {
                \lstinputlisting[language=Python, lastline=16]{./code/countably_inf.py}

                \begin{verbatim}
2. a.
[0, -1, 1, -2, 2, -3, 3, -4, 4, -5, 5]        
                \end{verbatim}
            }

            \item {
                \lstinputlisting[language=Python, firstline=18, lastline=31]{./code/countably_inf.py}

                \begin{verbatim}
2. b. 
[9, 7, 5, 3, 1, 0, 2, 4, 6, 8, 10]
[-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
                \end{verbatim}
            }

            \item {
                Here, my implementation may seem a bit unorthodox. If you are 
                familiar with Generators in Python, then skip ahead to the 
                implementation. 
                
                Rather than defining an actual function \(h\) that receives 
                a natural number and outputs a specific tuple 
                \(t \in \mathbb{N } \times \mathbb{N}\),  I return a Generator 
                object that allows you to iterate through an infinitely many
                tuples \(t \in \mathbb{N } \times \mathbb{N}\). This way, 
                \(h(1)\) is the first elements returned in the iteration, and 
                \(h(2)\) is the second, etc.

                Note: I use the type hint Iterator rather than Generator because 
                All Generators are Iterators. This works just fine if done with 
                Iterator objects.
            }

            \lstinputlisting[language=Python, firstline=33, lastline=64]{./code/countably_inf.py}
            \begin{verbatim}
2. c. 
[(0, 0), (0, 1), (1, 0), (0, 2), (1, 1), (2, 0), (0, 3), (1, 2), (2, 1), (3, 0),
 (0, 4)]
            \end{verbatim}

            \item {
                The logic used in the previous part of this exercise can be 
                generalized to any countably infinite sets. (could there be some
                `bijection' between countably infinite sets and Generator objects?)

                \lstinputlisting[language=Python, firstline=66, lastline=96]{./code/countably_inf.py}

                \begin{verbatim}
2. d. 
A1:  [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
A2:  ['', '0', '1', '00', '01', '10', '11', '000', '001', '010', '011']
f_prime:  [(0, ''), (0, '0'), (1, ''), (0, '1'), (1, '0'), (1, ''), (0, '00'), 
(1, '1'), (1, '0'), (2, ''), (0, '01')]
                \end{verbatim}
            }

            \item {
                We define a function to take the cartesian product of an infinite
                set (represented as a Generator) with itself \(k\) times.

                Now, this creates some odd data structures since my implementation
                of the cartesian product creates a tuple of the two original data 
                types. When taking many cartesian products, you end up with deeply 
                nested tuples. Luckily, these tuples are isomorphic to its own 
                flattened counterpart. In other words, there exists a bijection 
                between arbitrarily nested tuples (a tree of sorts), to an arbitrarily
                long 1-dimensional tuple that can be expressed in code.

                \lstinputlisting[language=Python, firstline=98]{./code/countably_inf.py}
                \begin{verbatim}
2. e.
b_k:  [((0, 0), (0, 0)), ((0, 0), (0, 1)), ((0, 1), (0, 0))]
b_k_flat:  [(0, 0, 0, 0), (0, 0, 0, 1), (0, 1, 0, 0), (0, 0, 1, 0),
 (0, 1, 0, 1), (1, 0, 0, 0), (0, 0, 0, 2), (0, 1, 1, 0), (1, 0, 0, 1), 
 (0, 2, 0, 0), (0, 0, 1, 1)]
                \end{verbatim}
            }
        \end{enumerate}
    }
\end{enumerate}

\includepdf[pages=-]{portfolio.pdf}
\end{document}